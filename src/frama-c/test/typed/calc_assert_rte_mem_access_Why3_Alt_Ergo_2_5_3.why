(* WP Task for Prover Alt-Ergo,2.5.3 *)
;;; this is a prelude for Alt-Ergo, Dolmen frontend
(set-logic ALL)
(set-info :smt-lib-version 2.6)
;;; generated by SMT-LIB2 driver
;;; SMT-LIB2: integer arithmetic
;;; SMT-LIB2: real arithmetic
;; "CompatOrderMult"
(assert
  (forall ((x Int) (y Int) (z Int))
    (=> (<= x y) (=> (<= 0 z) (<= (* x z) (* y z))))))

;; "abs"
(define-fun abs1 ((x Int)) Int
  (ite (<= 0 x) x (- x)))

;; "Abs_le"
(assert (forall ((x Int) (y Int)) (=> (<= (abs1 x) y) (<= (- y) x))))

;; "Abs_le"
(assert (forall ((x Int) (y Int)) (=> (<= (abs1 x) y) (<= x y))))

;; "Abs_le"
(assert
  (forall ((x Int) (y Int)) (=> (and (<= (- y) x) (<= x y)) (<= (abs1 x) y))))

;; "Abs_pos"
(assert (forall ((x Int)) (<= 0 (abs1 x))))

;; "div"
(declare-fun div1 (Int
  Int) Int)

;; "mod"
(declare-fun mod1 (Int
  Int) Int)

;; "Div_mod"
(assert
  (forall ((x Int) (y Int))
    (=> (not (= y 0)) (= x (+ (* y (div1 x y)) (mod1 x y))))))

;; "Div_bound"
(assert
  (forall ((x Int) (y Int)) (=> (and (<= 0 x) (< 0 y)) (<= 0 (div1 x y)))))

;; "Div_bound"
(assert
  (forall ((x Int) (y Int)) (=> (and (<= 0 x) (< 0 y)) (<= (div1 x y) x))))

;; "Mod_bound"
(assert
  (forall ((x Int) (y Int)) (=> (not (= y 0)) (< (- (abs1 y)) (mod1 x y)))))

;; "Mod_bound"
(assert
  (forall ((x Int) (y Int)) (=> (not (= y 0)) (< (mod1 x y) (abs1 y)))))

;; "Div_sign_pos"
(assert
  (forall ((x Int) (y Int)) (=> (and (<= 0 x) (< 0 y)) (<= 0 (div1 x y)))))

;; "Div_sign_neg"
(assert
  (forall ((x Int) (y Int)) (=> (and (<= x 0) (< 0 y)) (<= (div1 x y) 0))))

;; "Mod_sign_pos"
(assert
  (forall ((x Int) (y Int))
    (=> (and (<= 0 x) (not (= y 0))) (<= 0 (mod1 x y)))))

;; "Mod_sign_neg"
(assert
  (forall ((x Int) (y Int))
    (=> (and (<= x 0) (not (= y 0))) (<= (mod1 x y) 0))))

;; "Rounds_toward_zero"
(assert
  (forall ((x Int) (y Int))
    (=> (not (= y 0)) (<= (abs1 (* (div1 x y) y)) (abs1 x)))))

;; "Div_1"
(assert (forall ((x Int)) (= (div1 x 1) x)))

;; "Mod_1"
(assert (forall ((x Int)) (= (mod1 x 1) 0)))

;; "Div_inf"
(assert
  (forall ((x Int) (y Int)) (=> (and (<= 0 x) (< x y)) (= (div1 x y) 0))))

;; "Mod_inf"
(assert
  (forall ((x Int) (y Int)) (=> (and (<= 0 x) (< x y)) (= (mod1 x y) x))))

;; "Div_mult"
(assert
  (forall ((x Int) (y Int) (z Int))
    (! (=>
         (and (< 0 x) (and (<= 0 y) (<= 0 z)))
         (= (div1 (+ (* x y) z) x) (+ y (div1 z x)))) :pattern ((div1
                                                                  (+ (* x y) z)
                                                                  x)) )))

;; "Mod_mult"
(assert
  (forall ((x Int) (y Int) (z Int))
    (! (=>
         (and (< 0 x) (and (<= 0 y) (<= 0 z)))
         (= (mod1 (+ (* x y) z) x) (mod1 z x))) :pattern ((mod1
                                                            (+ (* x y) z)
                                                            x)) )))

;; "CompatOrderMult"
(assert
  (forall ((x Real) (y Real) (z Real))
    (=> (<= x y) (=> (<= 0.0 z) (<= (* x z) (* y z))))))

;; "c_euclidian"
(assert
  (forall ((n Int) (d Int))
    (! (=> (not (= d 0)) (= n (+ (* (div1 n d) d) (mod1 n d)))) :pattern (
    (div1
      n
      d)
    (mod1 n d)) )))

;; "cmod_remainder"
(assert
  (forall ((n Int) (d Int))
    (! (=> (<= 0 n) (=> (< 0 d) (<= 0 (mod1 n d)))) :pattern ((mod1 n d)) )))

;; "cmod_remainder"
(assert
  (forall ((n Int) (d Int))
    (! (=> (<= 0 n) (=> (< 0 d) (< (mod1 n d) d))) :pattern ((mod1 n d)) )))

;; "cmod_remainder"
(assert
  (forall ((n Int) (d Int))
    (! (=> (<= n 0) (=> (< 0 d) (< (- d) (mod1 n d)))) :pattern ((mod1 n d)) )))

;; "cmod_remainder"
(assert
  (forall ((n Int) (d Int))
    (! (=> (<= n 0) (=> (< 0 d) (<= (mod1 n d) 0))) :pattern ((mod1 n d)) )))

;; "cmod_remainder"
(assert
  (forall ((n Int) (d Int))
    (! (=> (<= 0 n) (=> (< d 0) (<= 0 (mod1 n d)))) :pattern ((mod1 n d)) )))

;; "cmod_remainder"
(assert
  (forall ((n Int) (d Int))
    (! (=> (<= 0 n) (=> (< d 0) (< (mod1 n d) (- d)))) :pattern ((mod1 n d)) )))

;; "cmod_remainder"
(assert
  (forall ((n Int) (d Int))
    (! (=> (<= n 0) (=> (< d 0) (< d (mod1 n d)))) :pattern ((mod1 n d)) )))

;; "cmod_remainder"
(assert
  (forall ((n Int) (d Int))
    (! (=> (<= n 0) (=> (< d 0) (<= (mod1 n d) 0))) :pattern ((mod1 n d)) )))

;; "cdiv_neutral"
(assert (forall ((a Int)) (! (= (div1 a 1) a) :pattern ((div1 a 1)) )))

;; "cdiv_inv"
(assert
  (forall ((a Int))
    (! (=> (not (= a 0)) (= (div1 a a) 1)) :pattern ((div1 a a)) )))

;; "cdiv_closed_remainder"
(assert
  (forall ((a Int) (b Int) (n Int))
    (=>
      (<= 0 a)
      (=>
        (<= 0 b)
        (=>
          (and (<= 0 (- b a)) (< (- b a) n))
          (=> (= (mod1 a n) (mod1 b n)) (= a b)))))))

(declare-sort addr 0)

;; "addr'mk"
(declare-fun addrqtmk (Int
  Int) addr)

;; "base"
(declare-fun base (addr) Int)

;; "base'def"
(assert (forall ((u Int) (u1 Int)) (= (base (addrqtmk u u1)) u)))

;; "offset"
(declare-fun offset (addr) Int)

;; "offset'def"
(assert (forall ((u Int) (u1 Int)) (= (offset (addrqtmk u u1)) u1)))

;; "addr_inversion"
(assert (forall ((u addr)) (= u (addrqtmk (base u) (offset u)))))

;; "null"
(define-fun null () addr
  (addrqtmk 0 0))

;; "global"
(define-fun global ((b Int)) addr
  (addrqtmk b 0))

;; "addr_le"
(declare-fun addr_le (addr
  addr) Bool)

;; "addr_lt"
(declare-fun addr_lt (addr
  addr) Bool)

;; "addr_le_bool"
(declare-fun addr_le_bool (addr
  addr) Bool)

;; "addr_lt_bool"
(declare-fun addr_lt_bool (addr
  addr) Bool)

;; "addr_le_def"
(assert
  (forall ((p addr) (q addr))
    (! (=>
         (= (base p) (base q))
         (=> (addr_le p q) (<= (offset p) (offset q)))) :pattern ((addr_le
                                                                    p
                                                                    q)) )))

;; "addr_le_def"
(assert
  (forall ((p addr) (q addr))
    (! (=>
         (= (base p) (base q))
         (=> (<= (offset p) (offset q)) (addr_le p q))) :pattern ((addr_le
                                                                    p
                                                                    q)) )))

;; "addr_lt_def"
(assert
  (forall ((p addr) (q addr))
    (! (=>
         (= (base p) (base q))
         (=> (addr_lt p q) (< (offset p) (offset q)))) :pattern ((addr_lt
                                                                   p
                                                                   q)) )))

;; "addr_lt_def"
(assert
  (forall ((p addr) (q addr))
    (! (=>
         (= (base p) (base q))
         (=> (< (offset p) (offset q)) (addr_lt p q))) :pattern ((addr_lt
                                                                   p
                                                                   q)) )))

;; "addr_le_bool_def"
(assert
  (forall ((p addr) (q addr))
    (! (=> (addr_le p q) (= (addr_le_bool p q) true)) :pattern ((addr_le_bool
                                                                  p
                                                                  q)) )))

;; "addr_le_bool_def"
(assert
  (forall ((p addr) (q addr))
    (! (=> (= (addr_le_bool p q) true) (addr_le p q)) :pattern ((addr_le_bool
                                                                  p
                                                                  q)) )))

;; "addr_lt_bool_def"
(assert
  (forall ((p addr) (q addr))
    (! (=> (addr_lt p q) (= (addr_lt_bool p q) true)) :pattern ((addr_lt_bool
                                                                  p
                                                                  q)) )))

;; "addr_lt_bool_def"
(assert
  (forall ((p addr) (q addr))
    (! (=> (= (addr_lt_bool p q) true) (addr_lt p q)) :pattern ((addr_lt_bool
                                                                  p
                                                                  q)) )))

;; "valid_rw"
(define-fun valid_rw ((m (Array Int Int)) (p addr) (n Int)) Bool
  (=>
    (< 0 n)
    (and
      (< 0 (base p))
      (and (<= 0 (offset p)) (<= (+ (offset p) n) (select m (base p)))))))

;; "valid_rd"
(define-fun valid_rd ((m (Array Int Int)) (p addr) (n Int)) Bool
  (=>
    (< 0 n)
    (and
      (not (= 0 (base p)))
      (and (<= 0 (offset p)) (<= (+ (offset p) n) (select m (base p)))))))

;; "valid_rw_rd"
(assert
  (forall ((m (Array Int Int)))
    (forall ((p addr))
      (forall ((n Int)) (=> (valid_rw m p n) (valid_rd m p n))))))

;; "valid_string"
(assert
  (forall ((m (Array Int Int)))
    (forall ((p addr))
      (=>
        (< (base p) 0)
        (=>
          (and (<= 0 (offset p)) (< (offset p) (select m (base p))))
          (valid_rd m p 1))))))

;; "valid_string"
(assert
  (forall ((m (Array Int Int)))
    (forall ((p addr))
      (=>
        (< (base p) 0)
        (=>
          (and (<= 0 (offset p)) (< (offset p) (select m (base p))))
          (not (valid_rw m p 1)))))))

;; "included"
(define-fun included ((p addr) (lp Int) (q addr) (lq Int)) Bool
  (=>
    (< 0 lp)
    (and
      (<= 0 lq)
      (and
        (= (base p) (base q))
        (and
          (<= (offset q) (offset p))
          (<= (+ (offset p) lp) (+ (offset q) lq)))))))

;; "separated"
(define-fun separated ((p addr) (lp Int) (q addr) (lq Int)) Bool
  (or
    (<= lp 0)
    (or
      (<= lq 0)
      (or
        (not (= (base p) (base q)))
        (or
          (<= (+ (offset q) lq) (offset p))
          (<= (+ (offset p) lp) (offset q)))))))

;; "separated_1"
(assert
  (forall ((p addr) (q addr))
    (forall ((lp Int) (lq Int) (i Int) (j Int))
      (! (=>
           (separated p lp q lq)
           (=>
             (and (<= (offset p) i) (< i (+ (offset p) lp)))
             (=>
               (and (<= (offset q) j) (< j (+ (offset q) lq)))
               (not (= (addrqtmk (base p) i) (addrqtmk (base q) j)))))) :pattern (
      (separated
        p
        lp
        q
        lq)
      (addrqtmk (base p) i)
      (addrqtmk (base q) j)) ))))

;; "separated_included"
(assert
  (forall ((p addr) (q addr))
    (forall ((lp Int) (lq Int))
      (! (=>
           (< 0 lp)
           (=>
             (< 0 lq)
             (=> (separated p lp q lq) (not (included p lp q lq))))) :pattern (
      (separated
        p
        lp
        q
        lq)
      (included p lp q lq)) ))))

;; "included_trans"
(assert
  (forall ((p addr) (q addr) (r addr))
    (forall ((lp Int) (lq Int) (lr Int))
      (! (=>
           (included p lp q lq)
           (=> (included q lq r lr) (included p lp r lr))) :pattern (
      (included
        p
        lp
        q
        lq)
      (included q lq r lr)) ))))

;; "separated_trans"
(assert
  (forall ((p addr) (q addr) (r addr))
    (forall ((lp Int) (lq Int) (lr Int))
      (! (=>
           (included p lp q lq)
           (=> (separated q lq r lr) (separated p lp r lr))) :pattern (
      (included
        p
        lp
        q
        lq)
      (separated q lq r lr)) ))))

;; "separated_sym"
(assert
  (forall ((p addr) (q addr))
    (forall ((lp Int) (lq Int))
      (! (=> (separated p lp q lq) (separated q lq p lp)) :pattern ((separated
                                                                    p
                                                                    lp
                                                                    q
                                                                    lq)) ))))

;; "separated_sym"
(assert
  (forall ((p addr) (q addr))
    (forall ((lp Int) (lq Int))
      (! (=> (separated q lq p lp) (separated p lp q lq)) :pattern ((separated
                                                                    p
                                                                    lp
                                                                    q
                                                                    lq)) ))))

;; "region"
(declare-fun region (Int) Int)

;; "linked"
(declare-fun linked ((Array Int Int)) Bool)

;; "static_malloc"
(declare-fun static_malloc (Int) Int)

;; "statically_allocated"
(define-fun statically_allocated ((base1 Int)) Bool
  (or (= base1 0) (< 0 (static_malloc base1))))

;; "valid_pointers_are_statically_allocated"
(assert
  (forall ((a addr) (m (Array Int Int)) (n Int))
    (=> (< 0 n) (=> (valid_rd m a n) (statically_allocated (base a))))))

;; "int_of_addr"
(declare-fun int_of_addr (addr) Int)

;; "addr_of_int"
(declare-fun addr_of_int (Int) addr)

;; "addr_of_null"
(assert (= (int_of_addr null) 0))

;; "addr_of_int_bijection"
(assert
  (forall ((p addr))
    (=> (statically_allocated (base p)) (= (addr_of_int (int_of_addr p)) p))))

(declare-sort table 0)

;; "table_to_offset"
(declare-fun table_to_offset (table
  Int) Int)

;; "table_to_offset_zero"
(assert (forall ((t table)) (= (table_to_offset t 0) 0)))

;; "table_to_offset_monotonic"
(assert
  (forall ((t table))
    (forall ((o1 Int) (o2 Int))
      (=> (<= o1 o2) (<= (table_to_offset t o1) (table_to_offset t o2))))))

;; "table_to_offset_monotonic"
(assert
  (forall ((t table))
    (forall ((o1 Int) (o2 Int))
      (=> (<= (table_to_offset t o1) (table_to_offset t o2)) (<= o1 o2)))))

;; "Q_L_x_24_region"
(assert (= (region 25) 2))

;; "Q_L_x_24_linked"
(assert (forall ((t (Array Int Int))) (=> (linked t) (= (select t 25) 0))))

;; Goal "wp_goal"
(assert
  (not
  (forall ((t (Array Int Int)))
    (=> (linked t) (valid_rw (store t 25 1) (global 25) 1)))))

(check-sat)
